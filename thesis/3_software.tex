\subsection{Softwarerecherche}
Im folgenden Kapitel werden verschiedene Tools und Frameworks zur Realisierung von automatisierten Tests untersucht. Einen Überblick über zur Verfügung stehende Tools bieten dabei \textcite{unittest-overview} und Weitere.

\subsubsection{Karma}
\label{sec:Karma}
Karma ist ein Test-Runner für die Ausführung von JavaScript-Tests. Er wurde vom AngularJS-Team ins Leben gerufen und wird auf GitHub von einer Open-Source-Gemeinschaft weiterentwickelt.\cite{karma-index} Karma liegt als Paket \texttt{karma} im npm-Repository\cite{karma-faq}.

Karma ermöglicht die Nutzung diverser Testframeworks, wie Jasmine (s. Abschnitt \ref{sec:Jasmine}), Mocha (s. Abschnitt \ref{sec:Mocha}) oder QUnit (s. Abschnitt \ref{sec:QUnit}). Auch Continuous Integration Server wie Jenkins oder Travis werden unterstützt.\cite{karma-faq}

Grundlegend basiert Karma auf einem Client-Server-Prinzip, wobei Karma einen Webserver startet, welcher alle verbundenen Browser fernsteuert und in diesen die Tests ausführt. Ein Browser kann hierbei entweder manuell, also durch Aufruf der vom Karma-Server bereitgestellten URL, oder automatisiert, also indem der Browser durch Karma gestartet wird (vgl. Listing \ref{lst:karma-conf-js}), verbunden werden. In jeder Testumgebung wird der Quelltext mittels IFrame eingebunden, der Test ausgeführt und danach die Ergebnisse an den Server gesendet. Dort werden die Ergebnisse aufgearbeitet präsentiert oder automatisiert von übergeordneten Buildprozessen verarbeitet. Das verwendete Prinzip stammt aus einer Masterthesis \cite{karma-masterThesis}; tieferes Verständnis ist jedoch für die reine Nutzung von Karma nicht erforderlich.\cite{karma-howItWorks}

Für die Konfiguration wird eine JavaScript-Datei, die \texttt{karma.conf.js}, genutzt. Ein Beispiel findet sich in Listing \ref{lst:karma-conf-js}. Mit dieser beispielhaften Konfiguration wird für die Testausführung das Framework Jasmine (s. Abschnitt \ref{sec:Jasmine}) genutzt. Der Parameter \texttt{files} gibt an, welche Dateien von Karma ausgeliefert und beobachtet werden, und somit bei Änderung welcher Dateien die Tests automatisch erneut ausgeführt werden. Außerdem ist konfiguriert, dass bei Testdurchführung automatisch Firefox gestartet werden und in diesem die Tests ausgeführt werden soll.\cite{karma-configurationFile, karma-files}

\begin{figure}[H]
	\lstinputlisting[caption={Beispiel einer \texttt{karma.conf.js} (adaptiert nach \cite{karma-configurationFile, karma-files})}, label=lst:karma-conf-js]{lst/karma.conf.js}
\end{figure}

Die Funktionalität von Karma lässt sich mit Plugins erweitern. Sie werden für die Einbindung von Testframeworks, ein verändertes Ausgabeformat der Testergebnisse, Präprozessoren (z.\,B. für die Auslieferung von in JavaScript eingebettetem HTML oder die Ermittlung der Code Coverage)\cite{karma-preprocessors} oder die Einbindung von Browsern wie Firefox, Chrome oder PhantomJS (s. Abschnitt \ref{sec:PhantomJS}) benötigt. Jedes Plugin ist ein npm-Paket, daher werden Plugins über npm installiert. Karma bindet alle installierten Pakete mit dem Namen \texttt{karma-*} automatisch ein.\cite{karma-plugins} Im npm-Repository liegen über 1300 Karma-Plugins.\cite{karma-npm}

\subsubsection{Jasmine}
\label{sec:Jasmine}
Jasmine ist ein Behavior Driven Development Framework zum Test von JavaScript\cite{jasmine-introduction}. Es liegt unter \texttt{jasmine} im npm-Repository\cite{jasmine-getting-started}. Jasmine bietet eine saubere und einfache Syntax zur Beschreibung von Testfällen. Die Tests bestehen aus drei Ebenen: Testsuites, Spezifizierungen (\glqq Specs\grqq) und Erwartungen, also den eigentlichen Testassertions\cite{jasmine-introduction}. Ein beispielhafter Test findet sich in Listing \ref{lst:jasmine-1}.

Eine Testsuite beginnt auf oberster Ebene mit dem Aufruf der globalen JavaScript-Funktion \texttt{describe(string, function)}. Der String ist hierbei der Name der Testsuite, üblicherweise wird hier das Testsubjekt benannt. Die Funktion implementiert die Testsuite und besteht aus Specs.\cite{jasmine-introduction}

Ein Spec wird durch Aufruf der globalen Funktion \texttt{it(string, function)} angelegt. Der String enthält eine Beschreibung des Testfalls; nach dem BDD-Modell also eine Beschreibung des erwarteten Verhaltens. Die Funktion dient zum Überprüfen dieses Verhaltens und enthält Assertions, welche entweder \texttt{true} oder \texttt{false} ergeben. Liefern alle Assertions \texttt{true} so gilt die Spec als bestanden, ansonsten als durchgefallen.\cite{jasmine-introduction}

Eine Assertion besteht in Jasmine aus der Funktion \texttt{expect(object)}, welcher der tatsächliche Wert übergeben wird. Diese wird mit einer Matcher-Funktion verkettet, welche den erwarteten Wert übergeben bekommt und die beiden Werte vergleicht und auswertet. Es wird eine Vielzahl an vorgefertigten Matchern mitgeliefert: \texttt{toEqual}, \texttt{toContain}, \texttt{toBeTruthy}, und Weitere\cite{jasmine-introduction, jasmine-cheatsheet}.

\begin{figure}[H]
	\lstinputlisting[caption={Beispiel einer Jasmine-Testsuite (adaptiert nach \cite{jasmine-introduction})}, label=lst:jasmine-1]{lst/jasmine-1.js}
\end{figure}

Specs können als \textit{pending} deklariert werden. Sie werden dann nicht ausgeführt, aber im Ergebnis angezeigt. Hierfür kann beim Aufruf der \texttt{it}-Funktion die Übergabe einer Funktion weggelassen werden, stattdessen die \texttt{xit}-Funktion aufgerufen werden oder im Funktionskörper die \texttt{pending}-Funktion genutzt werden.\cite{jasmine-introduction}

\subsubsection{Protractor}
\label{sec:Protractor}
Protractor ist ein speziell für Angular-Anwendungen entwickeltes Framework für End-to-End-Tests. Die Tests werden in Browsern direkt gegen die Anwendungsoberfläche durchgeführt und simulieren somit das Verhalten eines echten Benutzers. Es liegt im npm-Repository mit der ID \texttt{protractor} und ist dadurch einfach zu installieren.\cite{protractor-index}

Für die Steuerung des Browsers greift Protractor auf Selenium zurück\cite{protractor-index}, welches den W3C WebDriver-Standard implementiert und als Proxyserver zwischen Protractor und dem Browser agiert\cite{selenium}. Selenium unterstützt alle großen Webbrowser: aktuell die aktuellsten Versionen von Firefox, Internet Explorer ab Version 7, Safari ab Version 5.1, Opera und Chrome\cite{selenium-browsers}. Vom Einsatz von PhantomJS (s. Abschnitt \ref{sec:PhantomJS}) zusammen mit Protractor wird ausdrücklich abgeraten, da es hier Berichten zufolge häufig zu Abstürzen und abweichendem Verhalten kommt\cite{protractor-browser}. Laut eigener Aussage wird Selenium automatisch zusammen mit Protractor installiert und ist nach Aufruf von \texttt{webdriver-manager update} und \texttt{webdriver-manager start} ohne weitere Konfiguration lauffähig\cite{protractor-index}.

Protractor nutzt als Framework für die Testbeschreibung standardmäßig Jasmine (s. Abschnitt \ref{sec:Jasmine}), unterstützt out-of-the-box aber auch Mocha (s. Abschnitt \ref{sec:Mocha}). Die nachfolgenden Beispiele nutzen daher auch Jasmine. Das eingesetzte Testframework, die Adresse unter welcher der Selenium-Server angesprochen wird, Testdateien, Timeouts, für den Test zu verwendende Browser und weitere Feineinstellungen werden in einer Konfigurationsdatei (s. Listing \ref{lst:protractor-conf}) konfiguriert.

\begin{figure}[H]
	\lstinputlisting[caption={Beispiel einer Protractor-Konfiguration (adaptiert nach \cite{protractor-tutorial})}, label=lst:protractor-conf]{lst/protractor.conf.js}
\end{figure}

Üblicherweise hat jede zu testende Seite eine eigene Testsuite und jeder Testfall ist eine eigene Spec (s. Listing \ref{lst:protractor-spec}). Vor der eigentlichen Testdurchführung muss die jeweilige Seite aufgerufen werden: hierzu dient die durch Protractor bereitgestellte Funktion \texttt{browser.get(url)}. Es bietet sich an, diese in \texttt{beforeEach()} auszuführen, einer Funktion die durch Jasmine vor jedem Spec aufgerufen wird. Auf Elemente kann mit der Funktion \texttt{element} zugegriffen werden, welcher ein Locator übergeben wird. Locator sind ein durch Protractor definiertes Konstrukt und beschreiben, wie das Element gefunden werden kann. Um mit den gefundenen Elementen zu interagieren werden verschiedene Funktionen bereitgestellt: beispielsweise \texttt{sendKeys} zur Zeicheneingabe, \texttt{click} zum Simulieren eines Mausklicks oder \texttt{getText} um den Elementinhalt zu ermitteln.

\begin{figure}[H]
	\lstinputlisting[caption={Beispiel einer Spec für Protractor (aus \cite{protractor-tutorial})}, label=lst:protractor-spec]{lst/protractor.spec.js}
\end{figure}

\subsubsection{Mocha}
\label{sec:Mocha}
Mocha ist ein Testframework und Test-Runner, welches sowohl in Node.js als auch in Browsern lauffähig ist. Es liegt als Paket \texttt{mocha} im npm-Repository und kann darüber installiert werden.\cite{mocha-index}

Tests bestehen in Mocha aus drei Ebenen. Die Oberste sind die Testsuites, welche weitere Testsuites oder Testfälle enthalten können. Testfälle bestehen aus funktionalem Code sowie Assertions als eigentliche Testüberprüfung. Es werden verschiedene Stile zur Testbeschreibung unterstützt: BDD, TDD, QUnit und weitere, welche sich nur in ihrem Aussehen unterscheiden und Entwicklern ermöglichen, ihren eigenen Stil zur Definition von Tests zu wählen.\cite{mocha-index}

Für Assertions können in Mocha verschiedene Frameworks genutzt werden. In \cite{mocha-index} wird beispielsweise die Nutzung von \textit{should.js} bei Verwendung des BDD-Stils, \textit{expect.js} oder \textit{chai} (s. Abschnitt \ref{sec:Chai}) empfohlen. Es ist einem Entwickler somit möglich, Mocha auf die eigenen Vorlieben anzupassen.\cite{mocha-index}

Auf eine genauere Vorstellung und Codebeispiele wird an dieser Stelle aufgrund der Vielseitigkeit verzichtet.
\todo{Konfiguration, synchron-asynchron, Reporter, Src-Bsp}

\subsubsection{QUnit}
\label{sec:QUnit}
QUnit ist ein Framework für automatisierte Komponententests mit JavaScript und wird von jQuery und einer Vielzahl weiterer Projekten genutzt. Es liegt unter \texttt{qunitjs} als Paket im npm-Repository. Es kann sowohl in Browsern als auch in Node.js ausgeführt werden.\cite{qunit-index}

In QUnit geschriebene Tests ähneln denen vieler Testframeworks populärer anderer Sprachen, wie beispielsweise JUnit in Java. Ein Testfall wird mittels Aufruf von \texttt{QUnit.test(string, function)} definiert. In der übergebenen Funktion kann Testcode aufgerufen werden und das Ergebnis mit Assertions validiert werden. Wenn mindestens eine Assertion fehlschlägt, gilt der Test als fehlgeschlagen; sonst als bestanden. QUnit liefert Assertions mit: beispielsweise \texttt{assert.ok}, welche einen truthy Wert erwartet, oder \texttt{assert.equal}, welches zwei als gleich angesehene Werte erwartet.\cite{qunit-cookbook}

Tests können in durch Aufruf von \texttt{QUnit.module(string)} erzeugten Modulen gruppiert werden (s. Listing \ref{lst:qunit-test}). In Modulen kann Code ausgelagert werden, indem die vor und nach jedem Test aufgerufenen Funktionen \texttt{beforeEach} und \texttt{afterEach} definiert werden.\cite{qunit-cookbook}

\begin{figure}[H]
	\lstinputlisting[caption={Beispiel mehrerer Tests für QUnit (adaptiert nach \cite{qunit-cookbook})}, label=lst:qunit-test]{lst/qunit-1.js}
\end{figure}
\subsubsection{PhantomJS}
\label{sec:PhantomJS}

\subsubsection{Chai}
\label{sec:Chai}

\subsubsection{Cucumber}
\label{sec:Cucumber}

\subsubsection{Unit JS}
\label{sec:UnitJS}

\subsubsection{Buster.js}
\label{sec:BusterJS}

\subsubsection{Sinon}
\label{sec:Sinon}

\subsubsection{ngMock}
\label{sec:ngMock}

\subsubsection{Intern}
\label{sec:Intern}

\subsubsection{Ava}
\label{sec:Ava}
